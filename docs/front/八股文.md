---
title: 八股文
---

### TCP 三次握手

1. 第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）
2. 第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。

### TCP 四次挥手

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。
6. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

### 浏览器从输入到渲染的原理

1. UI 线程判断是搜索查询还是 URL。
2. 网络线程进行 DNS 解析，为请求建立 TLS 连接。
3. 网络线程读取请求，识别数据类型以及 MIME 类型校验。（其中识别状态码，若是 301 还需要重新发起一个 url 请求）
4. 根据类型进行处理以及 CORS 检查。（html 传给 GPU，zip 传给下载管理器）
5. 网络线程告诉 ui 线程数据准备就绪，ui 线程查找渲染器进程。（正常情况下，存在网络延迟，在第二步时 ui 线程已经找到了渲染器进程，并且渲染器进程处于待机状态）
6. 一个 IPC 从浏览器进程发送到渲染器进程以提交导航，，当渲染器进程接受完 html 数据后，导航完成，稳当渲染阶段开始。
7.

### CORS 检查

认证过程：

- 网站 A 对浏览器说：你去帮我找服务端 B 要个苹果。
- 浏览器对服务端 B 说: 我要个苹果。
- 服务端 B 对浏览器说: 呐，这是给你的苹果，另外给你个名单，只许这些人吃。
- 浏览器拿到苹果，对比了一下名单，发现 A 在名单里，便把苹果给 A 吃了。

##### 控制 CORS 检查的头字段：

请求头：

- Origin：表明预检请求或实际请求的源站 URL，不管是否跨域 ORIGIN 字段总被发送。
- Access-Control-Request-Method：将实际请求的 HTTP 方法告诉服务器。
- Access-Control-Request-Headers：将实际请求所携带的首部字段告诉服务器（请求头 header 中的字段）

响应头：

- Access-Control-Allow-Origin：指定允许访问该资源的 URL，对于携带身份凭证的请求不可使用通配符\*
- Access-Control-Expose-Headers：指定 XMLHttpRequest 的 getResponseHeader 可以访问的响应头。
- Access-Control-Max-Age：指定 preflight 请求的结果能狗被缓存多久。
- Access-Control-Allow-Credentials：是否允许浏览器读取 response 的内容。
- Access-Control-Allow-Methods：指明实际请求所允许使用的 HTTP 方法。
- Access-Control-Allow-Headers：指明实际请求所允许携带的首部字段。

### TCP UDP 协议，网络有哪些层

### 为什么 ESLint 可以检查和修复格式问题，而 babel 不可以？

AST 树中包含着这些信息，ESLint 中提供了根据 range 查询 token 的 api，而 Babel 中没有。EsLint 和 Babel 原理大同小异，但是有不同的设计目的，所以提供了不同的 api，有着不同的功能。

### V8 垃圾回收机制

首先来说, `v8 对堆内存是存在限制的`, 在 64 位系统下, 最多只能分配 1.4 个 g 的堆内存, 32 位系统 0.7 个 g, 对于栈内存来说, ESP 指针下移, 上下文切换, 栈顶空间就被自动回收了。

在 js 中，引用类型都是存储在堆中，比如创建一个对象时，就会在堆中开辟一个内存区域，不断往里面写入成员，那么堆的内存就越来越大, 让 v8 为他分配空间, 直到达到内存上限。

设置内存上限的原因：js 的是单线程，每次垃圾回收时需要将其余逻辑暂停。在完全清空 1.4g 堆内存的情况下，做一次垃圾回收需要 50ms 以上，做一次非增量式回收，甚至需要 1s 以上，堆内存大小可以调节

js 将堆内存分为两个部分

- 新生代，一般是临时分配的内存，容量不大，存活时间短（上限是 64 位 32m，32 位 16m）
- 老生代， 常驻内存，存活时间久，容量大。

回收方式

- 新生代
  - 将新生代一分为二，Form 表示正在使用的内存，to 表示闲置的内存。
  - 在进行垃圾回收的时候，v8 将 From 部分的对象都检查一遍，如果是存活的对象直接复制到 to 中，非存活的对象直接回收。
  - 当所有的存活对象都按顺序进入 To 中之后, 然后 To 和 From 身份对调, From 中的内存被闲置, To 中正在使用， 如此循环
  - 当然, 可能会出现存货对象在堆中分配不均匀的情况, 这就是所谓内存碎片, 需要使用一个算法对 To 中的内存进行整理(Scavenge 算法), 也叫碎片整理
  - 新生代的劣势很明显, 就是只使用了一半的空间, 但是处理生命周期很短的对象, 这样的对象不多, 因此效率很高
- 老生代
  - `晋升` 如果新生代中经过多次循环回收后，依然还在 Form 中存在，那么就会将其移到老生代中。
    发生`晋升`的原因如下：
    - 已经经历过一次 Scavenge 回收的对象
    - To（闲置）空间内存占用超过 25%
  - 第一步，进行标记、清除
    - 标记阶段：遍历所有对象，对他们做上标记，然后对代码中`使用的变量`和`强引用`的变量取消标记，剩下的都是要删除的变量
    - 清除阶段：回收空间。
  - 整理内存碎片，在老生代中很暴力，直接将存活对象往一端移动
- 增量标记
  - 由于 js 是单线程, 因此垃圾回收的时候不可避免的会阻塞业务的进行, 如果老生代中回收任务很重, 耗时会非常恐怖, 严重影响性能, 为了避开这个问题, V8 采用`增量标记`。
  - `增量标记`: 也就是将一口气完成的标记任务, 分为一块一块的小块, 完成一小块标记就停一下去执行 js 逻辑, 然后在执行下面的部分, 如此循环下去, 直到标记阶段完成, 才进入清除阶段, 然后整理碎片

### 性能优化

想要做好性能优化需要先了解整个开发的整个流程，在针对不同的步骤进行优化。

其中可以在用户体验上进行优化的主要是：打包（决定产出大小）、浏览器请求的过程（网络、浏览器资源缓存、渲染过程、交互阶段）

##### 打包阶段

打包时可以进行打包压缩、根据路由拆包的形式进行优化。

##### 网络

可以将 js、css 等静态资源通过 hash 标记表示唯一性，上传至 oss 对象存储服务器 并开通 cdn 加速，只有 index.html 需要走服务器。

http2.0 通过减少建立 tcp 时三次握手和四次挥手的过程进行优化

##### 浏览器资源缓存

> 缓存位置上区分

`Service Worker`

- `Service Worker`是运行在浏览器背后的独立线程, 一般用以实现缓存功能，可以拦截请求, 因此必须使用 HTTPS 协议来保障安全.
- 他与其他浏览器内建的缓存机制不同, 它支持我们自由控制缓存哪些文件, 如何匹配缓存, 如何读取缓存, 并且缓存是可持续性的.
- 在 PWA 这样的概念中, Service Worker 是其中的核心实现者, 可用作离线消息推送, 这个功能就是通过缓存来实现的
- 要注意的是, 当 Service Worker 没有命中缓存的时候, 会调用 fetch 函数获取数据, 也就是说如果 Service Worker 没有命中缓存, 会根据缓存优先级去查找数据。但是不管是从 Memory Cache 还是从请求中获取新的数据， 浏览器都会显示我们是从 Service Worker 中获取的。

`Memory Cache`

- Memory Cache 表示内存中的缓存, 主要包含的是当前页面中已经抓取的资源. 内存缓存读取比磁盘快, 但是在高效率读取的同时, 他的可持续性也非常短.会随着进程的释放而释放, 因此一旦我们关闭 Tab 页, 内存中的缓存也就释放了
- 不能存储在计算机的内存中, 谷歌默认使用的堆内存大约在 1.5 个 G, 不会给我们自由操作的空间
- 内存缓存中有一个很重要的缓存资源是由 preloader 相关指令下载的资源。 他是常见优化手段之一, 可以一边解析 js/css 一边请求下一个资源
- 注意: 内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值, 同时资源的匹配也并非仅仅是对 URL 做匹配, 还可能对 Content-type CORS 等其他特征做校验

`Disk Cache`

- Disk Cache 是存储在硬盘中的缓存, 读取速度慢了点, 但是什么都可以存, 对比内存缓存就胜在存储时效性和容量大。
- 在浏览器缓存中, 磁盘缓存覆盖面最大，他会根据 HTTP Header 来判断哪些资源需要缓存, 哪些资源不需要请求直接使用, 哪些资源已经过期需要重新请求
- 关于 `内存缓存` 和 `磁盘缓存`
  - 一般来说, 对于大文件, 大概率不会丢在内存中, 反之优先
  - 当前系统内存使用较高会优先丢入磁盘

`Push Cache`

- Push Cache(推送缓存)是 HTTP/2 中的内容, 当以上三种缓存都没有命中的时候, 他就会被使用。 它只在 Session(会话)状态中被使用, 一旦会话结束, 就会释, 并且缓存时间很短, 在 Chrome 中大概只有 5mins 左右, 同时也严格执行 HTTP 头中的缓存指令

> 以上四种都没有命中，则直接发起请求。
>
> 缓存策略上 分为 协商缓存 和 强缓存
>
> 强缓存是判断浏览器本地资源是否失效、协商缓存是判断服务器上资源是否更新，通过这样去记忆

`强缓存`

> 强缓存主要通过设置`Expiress`或者`Cache-Control`实现

- 浏览器发起 http 请求前，先到`浏览器缓存`。
- 浏览器缓存中处理有三种情况如下：
  - 浏览器缓存中没有缓存结果和缓存标识。
  - 该请求缓存结果失效，只返回缓存标识。
  - 存在缓存结果且未失效，返回缓存结果。
- 缓存未失效则直接使用缓存结果，不再发起 http 请求，其余情况则都发出 http，有缓存标识则带上缓存标识，没有就不带。

`协商缓存`

> 强缓存失效后，当 http 请求携带着缓存标识向服务器发起请求时，便开始进行协商缓存的流程。
>
> 协商缓存主要通过`Etag`和`Last-Modified`实现

- 浏览器携带缓存标识发起 http 请求到服务器。
- 服务器根据缓存标识判断资源有无更新
  - 服务器资源更新，返回 200 和请求结果。浏览器根据返回结果并更新浏览器缓存。
  - 服务器资源没有更新，返回 304 状态码，从浏览器缓存中获取数据，并更新浏览器缓存状态。

##### 渲染过程以及交互阶段

渲染过程和交互阶段，主要通过代码上的优化进行。
